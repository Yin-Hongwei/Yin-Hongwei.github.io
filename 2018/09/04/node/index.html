<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="NodeJS入门"><meta name="keywords" content="NodeJS"><meta name="author" content="Yin-Hongwei"><meta name="copyright" content="Yin-Hongwei"><title>NodeJS入门 | Hongwei Blog</title><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script></head><body><header id="header"><nav id="navbar"><span class="nav-left"><div class="tou-img"><img src="/img/tou.jpg"></div><a id="site-name" href="/">Hongwei Blog</a></span><i class="fa fa-bars toggle-menu nav-right" aria-hidden="true"></i><span class="nav-right menus"><a class="site-page" href="/about">关于</a><a class="site-page" href="/archives">存档</a><a class="site-page" href="/tags">标签</a></span></nav></header><article id="content-outer"><section id="content-inner"><article class="article-entry" id="post"><h1>NodeJS入门</h1><h2 id="什么是Node-js"><a href="#什么是Node-js" class="headerlink" title="什么是Node.js"></a>什么是Node.js</h2><blockquote>
<p>什么是Node.js</p>
</blockquote>
<p>JS是脚本语言，它需要一个解析器才能运行。对于写在HTML页面里的 JS，浏览器充当了解析器的角色。对于需要独立运行的JS，NodeJS就是一个解析器。</p>
<a id="more"></a> 
<blockquote>
<p>什么是解析器</p>
</blockquote>
<p>解析器是一种运行环境，不但允许 JS 定义各种数据结构进行各种计算，还允许 JS 使用运行环境提供的内置对象和方法做一些事情。例如运行在浏览器中的JS的用途是操作 DOM，浏览器就提供了document 之类的内置对象。而运行在 NodeJS 中的JS的用途是操作磁盘文件或搭建 HTTP 服务器，NodeJS 就相应提供了fs、http等内置对象。</p>
<h2 id="用来做什么"><a href="#用来做什么" class="headerlink" title="用来做什么"></a>用来做什么</h2><p>Node.js主要用于编写像Web服务器一样的网络应用，这和PHP，java和Python是类似的。但是Node.js与其他语言最大的不同之处在于，PHP等语言是阻塞的（只有前一条命令执行完毕才会执行后面的命令），而Node.js是非阻塞的（多条命令可以同时被运行，通过回调函数得知命令已结束运行）。</p>
<p>===&gt; 接受http请求，提供web页面</p>
<p>  1）引入require模块，载入node模块</p>
<p>  2）创建服务器</p>
<p>  3）接受请求和响应请求</p>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><h3 id="1-线程模型（其他语言服务器的任务处理模式）"><a href="#1-线程模型（其他语言服务器的任务处理模式）" class="headerlink" title="1.线程模型（其他语言服务器的任务处理模式）"></a>1.线程模型（其他语言服务器的任务处理模式）</h3><blockquote>
<p>过程：</p>
</blockquote>
<p>（1）来一个请求</p>
<p>（2）开一个线程处理</p>
<p>（3）处理完的结果返回客户端，线程释放</p>
<blockquote>
<p>缺点：</p>
</blockquote>
<p>当有大量客户端请求的时候，服务器端占用的资源会比较多，用户等待时间会比较长，是阻塞的处理。</p>
<p>而事件循环就解决了上面的问题。</p>
<h3 id="2-event-loop（事件循环）"><a href="#2-event-loop（事件循环）" class="headerlink" title="2.event loop（事件循环）"></a>2.event loop（事件循环）</h3><p>Node.js采用事件驱动、异步编程，为网络服务而设计。</p>
<blockquote>
<p>简单描述</p>
</blockquote>
<p>Node.js 是单进程单线程应用程序，Node.js运行起来后，初始化 event loop 开始接收请求。接收到请求后将请求放到事件队列里，然后在去等待用户的下一个请求。事件在队列里完成读取数据等操作，处理完请求后回调回来，把结果返回给客户端。</p>
<blockquote>
<p>详细描述</p>
</blockquote>
<p>每次的 event loop 包括如下6个阶段，每个阶段都有一个任务队列，当 event loop 到达某个阶段时，将执行该阶段的任务队列，直到队列清空或执行的回调达到系统上限后，才会转入下一个阶段。当所有阶段被顺序执行一次后，称 event loop 完成了一个 tick。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">timers 阶段：这个阶段执行timer（setTimeout、setInterval）的回调</span><br><span class="line"></span><br><span class="line">I/O callbacks 阶段：执行一些系统调用错误，比如网络通信的错误回调</span><br><span class="line"></span><br><span class="line">idle, prepare 阶段：仅node内部使用</span><br><span class="line"></span><br><span class="line">poll 阶段：获取新的I/O事件, 适当的条件下node将阻塞在这里</span><br><span class="line"></span><br><span class="line">check 阶段：执行 setImmediate() 的回调</span><br><span class="line"></span><br><span class="line">close callbacks 阶段：执行 socket 的 close 事件回调</span><br><span class="line"></span><br><span class="line">// 我们重点看timers、poll、check这3个阶段就好，因为日常开发中的绝大部分异步任务都是在这3个阶段处理的。</span><br><span class="line">// 在 microtask 队列中的任务有 process.nextTick 和 Promise。</span><br><span class="line">// 在 Macrotask 队列中的任务有 setTimeout、setInterval、setImmediate，I/O, UI rendering。</span><br></pre></td></tr></table></figure>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><blockquote>
<p>安装及运行</p>
</blockquote>
<blockquote>
<p>npm</p>
</blockquote>
<p>node.js官方提供的库功能很少，能做的事情有局限性，npm 提供了很多第三方的软件库。</p>
<p><a href="[https://github.com/Yin-Hongwei/notes/blob/master/%E5%B7%A5%E5%85%B7/npm.md](https://github.com/Yin-Hongwei/notes/blob/master/工具/npm.md">常用命令</a>)</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><blockquote>
<p>全局对象</p>
</blockquote>
<p>在浏览器 JavaScript 中，通常 window 是全局对象， 而 Node.js 中的全局对象是 global，所有全局变量（除了 global 本身以外）都是 global 对象的属性。</p>
<blockquote>
<p>函数</p>
</blockquote>
<p>Node.js中函数的使用与Javascript类似。</p>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>为了让 Node.js 的文件可以相互调用，Node.js提供了模块系统。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var hello = require(&apos;./hello&apos;) // require</span><br><span class="line"></span><br><span class="line">exports.world = function() &#123;&#125; // exports</span><br><span class="line"></span><br><span class="line">module.exports = function() &#123;&#125; // module</span><br></pre></td></tr></table></figure>
<blockquote>
<p>工具模块</p>
</blockquote>
<p><a href="http://www.runoob.com/nodejs/nodejs-os-module.html" target="_blank" rel="noopener">OS 模块</a>：提供基本的系统操作函数。</p>
<p><a href="http://www.runoob.com/nodejs/nodejs-path-module.html" target="_blank" rel="noopener">Path 模块</a>：提供了处理和转换文件路径的工具</p>
<p><a href="http://www.runoob.com/nodejs/nodejs-net-module.html" target="_blank" rel="noopener">Net 模块</a>：用于底层的网络通信。提供了服务端和客户端的的操作。</p>
<p><a href="http://www.runoob.com/nodejs/nodejs-dns-module.html" target="_blank" rel="noopener">DNS 模块</a>：用于解析域名</p>
<p><a href="http://www.runoob.com/nodejs/nodejs-domain-module.html" target="_blank" rel="noopener">Domain 模块</a>：简化异步代码的异常处理，可以捕捉处理try catch无法捕捉的。</p>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><h4 id="1-fs模块"><a href="#1-fs模块" class="headerlink" title="1.fs模块"></a>1.fs模块</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fs.open(path, flags[, mode], callback) // 打开文件</span><br><span class="line"></span><br><span class="line">fs.writeFile(file, data[, options], callback) // 写入文件</span><br><span class="line"></span><br><span class="line">fs.read(fd, buffer, offset, length, position, callback) // 读取文件</span><br><span class="line"></span><br><span class="line">fs.close(fd, callback) // 关闭文件</span><br><span class="line"></span><br><span class="line">fs.unlink(path, callback) // 删除文件</span><br><span class="line"></span><br><span class="line">fs.mkdir(path[, options], callback) // 创建目录</span><br><span class="line"></span><br><span class="line">fs.readdir(path, callback) // 读取目录</span><br><span class="line"></span><br><span class="line">fs.rmdir(path, callback) // 删除目录</span><br></pre></td></tr></table></figure>
<h4 id="2-Buffer-缓冲区"><a href="#2-Buffer-缓冲区" class="headerlink" title="2.Buffer(缓冲区)"></a>2.Buffer(缓冲区)</h4><blockquote>
<p>概念</p>
</blockquote>
<p>JavaScript 语言自身只有字符串数据类型，没有二进制数据类型。但在处理像TCP流或文件流时，必须使用到二进制数据。因此在 Node.js中，定义了一个 Buffer 类，该类用来创建一个专门存放二进制数据的缓存区。（计算机中所有的二进制会以十六进制去显示，因为二进制太长。）</p>
<p>Buffer 实例一般用于表示编码字符的序列，通过使用显式的字符编码，就可以在 Buffer 实例与普通的 JavaScript 字符串之间进行相互转换。</p>
<blockquote>
<p>方法</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Buffer.alloc(size[, fill[, encoding]]) // 创建 Buffer 类</span><br><span class="line"></span><br><span class="line">Buffer.from(string[, encoding]) // 创建 Buffer 类</span><br><span class="line"></span><br><span class="line">buf.write(string, offset[, length]) // 写入缓冲区</span><br><span class="line"></span><br><span class="line">buf.toString([encoding[, start[, end]]]) // 从缓冲区读取数据</span><br><span class="line"></span><br><span class="line">buf.toJSON() // 将 Buffer 转换为 JSON 对象</span><br><span class="line"></span><br><span class="line">Buffer.concat(list[, totalLength]) // 缓冲区合并</span><br><span class="line"></span><br><span class="line">buf.compare(otherBuffer); // 缓冲区比较</span><br><span class="line"></span><br><span class="line">buf.copy(targetBuffer[, targetStart[, sourceStart[, sourceEnd]]]) // 拷贝缓冲区</span><br><span class="line"></span><br><span class="line">buf.slice([start[, end]]) // 缓冲区裁剪</span><br><span class="line"></span><br><span class="line">buf.length // 缓冲区长度</span><br></pre></td></tr></table></figure>
<h4 id="3-Stream-流"><a href="#3-Stream-流" class="headerlink" title="3.Stream(流)"></a>3.Stream(流)</h4><blockquote>
<p>概念</p>
</blockquote>
<p>读取数据的一种方式。在node中读取文件的方式有来两种，一个是利用fs模块，一个是利用流来读取。如果读取小文件，我们可以使用fs读取，fs读取文件的时候，是将文件一次性读取到本地内存。而如果读取一个大文件，一次性读取会占用大量内存，效率很低，这个时候需要用流来读取。流是将数据分割段，一段一段的读取，效率很高。</p>
<blockquote>
<p>方法</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 从流中读取数据</span><br><span class="line">var readerStream = fs.createReadStream(文件inxx) //  创建可读流</span><br><span class="line"></span><br><span class="line">// 写入流</span><br><span class="line">var writerStream = fs.createWriteStream(文件outxx) // 创建一个可以写入的流，写入到文件outxx中</span><br><span class="line">writerStream.write(data,&apos;UTF8&apos;) // 使用 utf8 编码写入数据（将data写入文件outxx</span><br><span class="line"></span><br><span class="line">// 管道流：从一个流中获取数据并将数据传递到另外一个流中。</span><br><span class="line">var readerStream = fs.createReadStream(文件inxx) // 创建一个可读流</span><br><span class="line">var writerStream = fs.createWriteStream(文件outxx) // 创建一个可写流</span><br><span class="line">readerStream.pipe(writerStream) // 读取 文件inxx 内容，并将内容写入到 文件outxx 中</span><br></pre></td></tr></table></figure>
<h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>我们要为路由提供请求的 URL 和其他需要的 GET 及 POST 参数，随后路由需要根据这些数据来执行相应的代码。</p>
<p>url.parse()可以将一个完整的URL地址，分为很多部分，常用的有：host、port、pathname、path、query。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// querystring: (查询串)处理用户表单提交过来的数据。</span><br><span class="line">// url: // 解析请求，包括文件名</span><br><span class="line">var http = require(&quot;http&quot;);</span><br><span class="line">var url = require(&quot;url&quot;);</span><br><span class="line">function start() &#123;</span><br><span class="line">  function onRequest(request, response) &#123;</span><br><span class="line">    var pathname = url.parse(request.url).pathname;</span><br><span class="line">    console.log(&quot;Request for &quot; + pathname + &quot; received.&quot;);</span><br><span class="line">    response.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;text/plain&quot;&#125;);</span><br><span class="line">    response.write(&quot;Hello World&quot;);</span><br><span class="line">    response.end();</span><br><span class="line">  &#125;</span><br><span class="line">   http.createServer(onRequest).listen(8888);</span><br><span class="line">  console.log(&quot;Server has started.&quot;);</span><br><span class="line">&#125;</span><br><span class="line">exports.start = start;</span><br></pre></td></tr></table></figure>
<h2 id="连接-MySQL"><a href="#连接-MySQL" class="headerlink" title="连接 MySQL"></a>连接 MySQL</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 先创一个数据库todolist，建个表user并写点数据</span><br><span class="line">// npm install mysql装mysql包</span><br><span class="line">var mysql  = require(&apos;mysql&apos;);</span><br><span class="line"></span><br><span class="line">var connection = mysql.createConnection(&#123;</span><br><span class="line">    host     : &apos;localhost&apos;,</span><br><span class="line">    user     : &apos;root&apos;,</span><br><span class="line">    password : &apos;1026&apos;,</span><br><span class="line">    port: &apos;3306&apos;,</span><br><span class="line">    database: &apos;todolist&apos;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">connection.connect();</span><br><span class="line"></span><br><span class="line">var  sql = &apos;SELECT * FROM user&apos;;</span><br><span class="line">//查</span><br><span class="line">connection.query(sql,function (err, result) &#123;</span><br><span class="line">    if(err)&#123;</span><br><span class="line">        console.log(&apos;[SELECT ERROR] - &apos;,err.message);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    console.log(&apos;--------------------------SELECT----------------------------&apos;);</span><br><span class="line">    console.log(result);</span><br><span class="line">    console.log(&apos;------------------------------------------------------------\n&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">connection.end();</span><br></pre></td></tr></table></figure>
<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>两个文件放同一目录下，呼应开始说的，NodeJS就是===&gt; 接受http请求，提供web页面<br>index.html<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form action=&quot;&quot; method=&quot;post&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; name=&quot;name&quot;/&gt;&lt;br/&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; name=&quot;content&quot;/&gt;&lt;br/&gt;</span><br><span class="line">    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>Server.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&apos;http&apos;);</span><br><span class="line">const fs = require(&apos;fs&apos;);</span><br><span class="line">const querystring = require(&apos;querystring&apos;); //（查询串）处理用户表单提交过来的数据。</span><br><span class="line"></span><br><span class="line">const hostname = &apos;127.0.0.1&apos;;</span><br><span class="line">const port = 3000;</span><br><span class="line"></span><br><span class="line">const server = http.createServer(function (req, res)&#123;</span><br><span class="line">    if (req.method === &apos;POST&apos;) &#123;</span><br><span class="line">        var post = &apos;&apos;; // 定义一个post变量，用于暂存请求体的信息</span><br><span class="line">        // 通过req的data事件监听函数，每当接受到请求体的数据，就累加到post变量中</span><br><span class="line">        req.on(&apos;data&apos;,function (chunk) &#123;</span><br><span class="line">            post += chunk;</span><br><span class="line">        &#125;);</span><br><span class="line">        // 在end事件触发后，通过querystring.parse将post解析为真正的POST请求格式，然后向客户端返回。</span><br><span class="line">        req.on(&apos;end&apos;, function()&#123;</span><br><span class="line">            // 设置响应头部信息及编码</span><br><span class="line">            res.setHeader(&apos;Content-Type&apos;, &apos;text/html&apos;);</span><br><span class="line">            res.statusCode = 200;</span><br><span class="line">            // 解析参数</span><br><span class="line">            post = querystring.parse(post);</span><br><span class="line">            // 输出提交后页面的内容</span><br><span class="line">            res.write(post.name);</span><br><span class="line">            res.write(&quot;&lt;br/&gt;&quot;);</span><br><span class="line">            res.write(post.content);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; else&#123;</span><br><span class="line">        // 设置响应头部信息及编码</span><br><span class="line">        res.setHeader(&apos;Content-Type&apos;, &apos;text/html&apos;);</span><br><span class="line">        res.statusCode = 200;</span><br><span class="line">        // 同步读取文件</span><br><span class="line">        var data = fs.readFileSync(&apos;index.html&apos;, &apos;utf-8&apos;)</span><br><span class="line">        // 输出未提交时页面的内容</span><br><span class="line">        res.end(data.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(port, hostname, function () &#123;</span><br><span class="line">    console.log(`Server running at http://$&#123;hostname&#125;:$&#123;port&#125;/`);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/node1.jpg" width="300"><br><img src="/img/node2.jpg" width="300"></p>
<p>​        </p>
<div class="qr-code"></div><img class="qrcode-img" src="/img/weixin.jpg"><div class="qrcode-desc">微信打赏</div><div class="post-tag-list">标签: <a class="post-tags" href="/tags/NodeJS/">NodeJS</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2018/10/15/正则表达式/"><i class="fa fa-chevron-left"></i><span>javascript 之 正则表达式</span></a></div><div class="next-post pull-right"><a href="/2018/08/17/JS事件循环/"><span>JavaScript 之 Event Loop</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: 'e238e2d1f25ec6e15026',
  clientSecret: '3c4e537d46a59d056e6c0cc478b04784defafcfb',
  repo: 'Yin-Hongwei.github.io',
  owner: 'Yin-Hongwei',
  admin: 'Yin-Hongwei',
  id: md5(window.location.pathname)
})
gitalk.render('gitalk-container')</script></article></section></article><footer id="footer-outer"><div id="footer-inner"><p class="footer-text">Copyright &copy; 2018-2019</p><p class="footer-text">Designed by Yin-Hongwei</p></div></footer></body><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="/js/main.js" defer></script></html>