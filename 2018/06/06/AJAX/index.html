<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="AJAX 回调地狱和跨域的解决"><meta name="keywords" content="JavaScript"><meta name="author" content="Yin-Hongwei"><meta name="copyright" content="Yin-Hongwei"><title>AJAX 回调地狱和跨域的解决 | Hongwei Blog</title><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script></head><body><header id="header"><nav id="navbar"><span class="nav-left"><div class="tou-img"><img src="/img/tou.jpg"></div><a id="site-name" href="/">Hongwei Blog</a></span><i class="fa fa-bars toggle-menu nav-right" aria-hidden="true"></i><span class="nav-right menus"><a class="site-page" href="/about">关于</a><a class="site-page" href="/archives">存档</a><a class="site-page" href="/tags">标签</a></span></nav></header><article id="content-outer"><section id="content-inner"><article class="article-entry" id="post"><h1>AJAX 回调地狱和跨域的解决</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>本文主要介绍AJAX的使用及回调地狱和跨域的解决。😄</p>
<a id="more"></a>
<h2 id="一-AJAX"><a href="#一-AJAX" class="headerlink" title="一 AJAX"></a>一 AJAX</h2><p>Ajax 通过 XMLHttpRequest 对象能够与远程的服务器进行信息交互。在需要发送多个异步请求，并且每个请求之间需要相互依赖的时候，它返回的顺序不确定，有时候得不到我们想要的结果，如果想解决这个问题，这个时候要把下一个请求写到上一个请求的回调函数里，即嵌套方式来解决。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">doSomething(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">  doSomethingElse(result, <span class="function"><span class="keyword">function</span>(<span class="params">newResult</span>) </span>&#123;</span><br><span class="line">    doThirdThing(newResult, <span class="function"><span class="keyword">function</span>(<span class="params">finalResult</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Got the final result: '</span> + finalResult);</span><br><span class="line">    &#125;, failureCallback);</span><br><span class="line">  &#125;, failureCallback);</span><br><span class="line">&#125;, failureCallback);</span><br></pre></td></tr></table></figure>
<p>但是这样一层一层的嵌套，使回调函数的层级越来越多，很可能坠入回调地狱中，维护困难。为了解决这种回调顺序的不确定性，以及回调地狱，于是出现了 <strong>Promise</strong>。</p>
<h2 id="二-Promise"><a href="#二-Promise" class="headerlink" title="二 Promise"></a>二 Promise</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><h4 id="1）含义"><a href="#1）含义" class="headerlink" title="1）含义"></a>1）含义</h4><p>Promise 是一个对象，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。它将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。</p>
<h4 id="2）特点"><a href="#2）特点" class="headerlink" title="2）特点"></a>2）特点</h4><ul>
<li>对象的状态不受外界影响。<code>Promise</code>对象代表一个异步操作，有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和<code>rejected</code>（已失败）。只有异步操作的结果可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。</li>
<li>一旦状态改变，就不会再变，任何时候都可以得到这个结果。<code>Promise</code>对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>。只要这两种情况发生，状态就不会再变，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对<code>Promise</code>对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</li>
</ul>
<h4 id="3）缺点"><a href="#3）缺点" class="headerlink" title="3）缺点"></a>3）缺点</h4><ul>
<li>无法取消<code>Promise</code>，一旦新建它就会立即执行，无法中途取消。</li>
<li>如果不设置回调函数，<code>Promise</code>内部抛出的错误，不会反应到外部。</li>
<li>当处于<code>pending</code>状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</li>
</ul>
<h3 id="2-Promise-实例"><a href="#2-Promise-实例" class="headerlink" title="2.Promise 实例"></a>2.Promise 实例</h3><p>Promise 对象是一个构造函数，用来生成 Promise 实例， Promise 构造函数接受一个函数作为参数，该函数的两个参数分别是 resolve 和 reject 。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。</p>
<p>resolve 函数的作用：将 Promise 对象的状态从 pending（未完成）变为 resolved（成功），在异步操作成功时调用，并将异步操作的结果作为参数传递出去。</p>
<p>reject 函数的作用：将 Promise 对象的状态从 pending（未完成）变为 rejected（失败），在异步操作失败时调用，并将异步操作报出的错误作为参数传递出去。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ... some code</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)&#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="3-方法"><a href="#3-方法" class="headerlink" title="3.方法"></a>3.方法</h3><h4 id="1）then"><a href="#1）then" class="headerlink" title="1）then"></a>1）then</h4><p>它的作用是 Promise 实例生成以后，为 Promise 实例添加状态改变（resolved、rejected）时的回调函数。then 方法可以接受两个回调函数作为参数。第一个回调函数是 Promise 对象的状态变为 resolved 时调用，第二个回调函数是 Promise 对象的状态变为 rejected 时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受 Promise 对象传出的值作为参数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// failure</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Promise 新建后就会立即执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Promise'</span>);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'resolved.'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Hi!'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise</span></span><br><span class="line"><span class="comment">// Hi!</span></span><br><span class="line"><span class="comment">// resolved</span></span><br><span class="line"><span class="comment">// 上面代码中，Promise 新建后立即执行，所以首先输出的是Promise。然后，then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以resolved最后输出。</span></span><br></pre></td></tr></table></figure>
<p>调用<code>resolve</code>或<code>reject</code>并不会终结 Promise 的参数函数的执行。因为立即 resolved 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(r);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p><code>then</code>方法返回的是一个新的<code>Promise</code>实例（注意，不是原来那个<code>Promise</code>实例）。因此可以采用链式写法，即<code>then</code>方法后面再调用另一个<code>then</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getJSON(<span class="string">"/posts.json"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> json.post;</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">post</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="2）catch"><a href="#2）catch" class="headerlink" title="2）catch"></a>2）catch</h4><p><code>Promise.prototype.catch</code>方法是<code>.then(null, rejection)</code>或<code>.then(undefined, rejection)</code>的别名，用于指定发生错误时的回调函数。Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个<code>catch</code>语句捕获。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">doSomething()</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> doSomethingElse(result))</span><br><span class="line">.then(<span class="function"><span class="params">newResult</span> =&gt;</span> doThirdThing(newResult))</span><br><span class="line">.then(<span class="function"><span class="params">finalResult</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Got the final result: <span class="subst">$&#123;finalResult&#125;</span>`</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(failureCallback);</span><br></pre></td></tr></table></figure>
<h4 id="3）finally"><a href="#3）finally" class="headerlink" title="3）finally"></a>3）finally</h4><p><code>finally</code>方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。<code>finally</code>方法的回调函数不接受任何参数，所以<code>finally</code>方法里面的操作，与状态无关，不依赖于 Promise 的执行结果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">promise</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;···&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;···&#125;)</span><br><span class="line">.finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;···&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="4）all"><a href="#4）all" class="headerlink" title="4）all"></a>4）all</h4><p><code>Promise.all</code>方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。当所有的Promise的结果都是resolve，才会去执行then方法里的内容。如果有一个是reject，就会执行catch里的内容。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span></span><br><span class="line">.all([Promise1, Promise2])</span><br><span class="line">.then(res = &gt; &#123;…&#125;)</span><br><span class="line">.catch(err = &gt; &#123;…&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="5）race"><a href="#5）race" class="headerlink" title="5）race"></a>5）race</h4><p><code>Promise.race</code>方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。状态由第一个返回的Promise得状态决定，第一个是resolve就执行then，返回的是reject就执行catch。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span></span><br><span class="line">.race([Promise1, Promise2])</span><br><span class="line">.then(res = &gt; &#123;…&#125;)</span><br><span class="line">.catch(err = &gt; &#123;…&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="6）resolve"><a href="#6）resolve" class="headerlink" title="6）resolve"></a>6）resolve</h4><p>将现有对象转为 Promise 对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'foo'</span>)</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(<span class="string">'foo'</span>))</span><br></pre></td></tr></table></figure>
<h4 id="7）reject"><a href="#7）reject" class="headerlink" title="7）reject"></a>7）reject</h4><p><code>Promise.reject(reason)</code>方法也会返回一个新的 Promise 实例，该实例的状态为<code>rejected</code>。</p>
<h3 id="4-ES5实现promise"><a href="#4-ES5实现promise" class="headerlink" title="4.ES5实现promise"></a>4.ES5实现promise</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span></span><br><span class="line">  self.status = <span class="string">'pending'</span> <span class="comment">// Promise当前的状态</span></span><br><span class="line">  self.data = <span class="literal">undefined</span>  <span class="comment">// Promise的值</span></span><br><span class="line">  self.onResolvedCallback = [] <span class="comment">// Promise resolve时的回调函数集</span></span><br><span class="line">  self.onRejectedCallback = [] <span class="comment">// Promise reject时的回调函数集</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(self.status==<span class="string">'pending'</span>)&#123;</span><br><span class="line">          self.status==<span class="string">'fulfilled'</span>;</span><br><span class="line">          self.data=value;</span><br><span class="line">          <span class="comment">// 依次执行成功之后的函数栈</span></span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; self.onResolvedCallback.length; i++) &#123;</span><br><span class="line">            self.onResolvedCallback[i](value)</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">rejecte</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (self.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">       self.status = <span class="string">'rejected'</span>;</span><br><span class="line">       self.data = error;</span><br><span class="line">       <span class="comment">// 依次执行失败之后的函数栈</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; self.onRejectedCallback.length; i++) &#123;</span><br><span class="line">           self.onRejectedCallback[i](error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123; <span class="comment">// 考虑到执行executor的过程中有可能出错，所以我们用try/catch块给包起来，并且在出错后以catch到的值reject掉这个Promise</span></span><br><span class="line">    executor(resolve, reject) <span class="comment">// 执行executor</span></span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    reject(e)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onResolved, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">var</span> promise2;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据标准，如果then的参数不是function，则我们需要忽略它，此处以如下方式处理</span></span><br><span class="line">  onResolved = <span class="keyword">typeof</span> onResolved === <span class="string">'function'</span> ? onResolved : <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;&#125;</span><br><span class="line">  onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span> ? onRejected : <span class="function"><span class="keyword">function</span>(<span class="params">reason</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (self.status === <span class="string">'resolved'</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果promise1(此处即为this/self)的状态已经确定并且是resolved，我们调用onResolved</span></span><br><span class="line">    <span class="comment">// 因为考虑到有可能throw，所以我们将其包在try/catch块里</span></span><br><span class="line">    <span class="keyword">return</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> x = onResolved(self.data)</span><br><span class="line">        <span class="keyword">if</span> (x <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123; <span class="comment">// 如果onResolved的返回值是一个Promise对象，直接取它的结果做为promise2的结果</span></span><br><span class="line">          x.then(resolve, reject)</span><br><span class="line">        &#125;</span><br><span class="line">        resolve(x) <span class="comment">// 否则，以它的返回值做为promise2的结果</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        reject(e) <span class="comment">// 如果出错，以捕获到的错误做为promise2的结果</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 此处与前一个if块的逻辑几乎相同，区别在于所调用的是onRejected函数，就不再做过多解释</span></span><br><span class="line">  <span class="keyword">if</span> (self.status === <span class="string">'rejected'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> x = onRejected(self.data)</span><br><span class="line">        <span class="keyword">if</span> (x <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">          x.then(resolve, reject)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        reject(e)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (self.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">  <span class="comment">// 如果当前的Promise还处于pending状态，我们并不能确定调用onResolved还是onRejected，</span></span><br><span class="line">  <span class="comment">// 只能等到Promise的状态确定后，才能确实如何处理。</span></span><br><span class="line">  <span class="comment">// 所以我们需要把我们的**两种情况**的处理逻辑做为callback放入promise1(此处即this/self)的回调数组里</span></span><br><span class="line">  <span class="comment">// 逻辑本身跟第一个if块内的几乎一致，此处不做过多解释</span></span><br><span class="line">    <span class="keyword">return</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      self.onResolvedCallback.push(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">var</span> x = onResolved(self.data)</span><br><span class="line">          <span class="keyword">if</span> (x <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">            x.then(resolve, reject)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      self.onRejectedCallback.push(<span class="function"><span class="keyword">function</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">var</span> x = onRejected(self.data)</span><br><span class="line">          <span class="keyword">if</span> (x <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">            x.then(resolve, reject)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了下文方便，我们顺便实现一个catch方法</span></span><br><span class="line"><span class="built_in">Promise</span>.prototype.catch = <span class="function"><span class="keyword">function</span>(<span class="params">onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">null</span>, onRejected)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考链接： <a href="https://juejin.im/post/5b2f02cd5188252b937548ab" target="_blank" rel="noopener">https://juejin.im/post/5b2f02cd5188252b937548ab</a></p>
<h2 id="三-Axios"><a href="#三-Axios" class="headerlink" title="三 Axios"></a>三 Axios</h2><p>Axios 是一个基于 promise 的 HTTP 库，支持Promise API，能帮助我们发起AJAX请求。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">axios.get(‘ https:<span class="comment">//baidu……’)</span></span><br><span class="line">.then(res = &gt; &#123;…&#125;)</span><br><span class="line">.catch(err = &gt; &#123;…&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="四-跨域"><a href="#四-跨域" class="headerlink" title="四 跨域"></a>四 跨域</h2><h3 id="同源策略：浏览器的一种安全机制"><a href="#同源策略：浏览器的一种安全机制" class="headerlink" title="同源策略：浏览器的一种安全机制"></a>同源策略：浏览器的一种安全机制</h3><p>URL由协议、域名、端口和路径组成，如果两个URL的协议、域名和端口相同，则表示他们同源。当浏览器从一个域名的网页去请求另一个域名的资源时，协议、域名、端口任一一个不同都是跨域。AJAX 受同源策略影响，不能发送跨域请求。下面是解决跨域的几种方式。</p>
<h3 id="1-远程代理"><a href="#1-远程代理" class="headerlink" title="1.远程代理"></a>1.远程代理</h3><p>同源策略是浏览器的安全策略，不是HTTP协议的要求。所以只要将请求的发送方交由服务端发送就可以绕过同源策略了。远程代理就是利用别人写好的代理接口代理发送你的请求，就不存在跨域问题了。</p>
<p>首先我们定义一个常量  API_PROXY 来保存代理的接口</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> API_PROXY = <span class="string">'https://bird.ioliu.cn/v1/?url='</span></span><br></pre></td></tr></table></figure>
<p>然后在axios请求里面和你的url拼接一下就OK了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axios.get(_this.$store.state.API_PROXY + <span class="string">'http://news-at.zhihu.com/api/4/stories/latest'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="2-JSONP"><a href="#2-JSONP" class="headerlink" title="2.JSONP"></a>2.JSONP</h3><p>JSONP 实现跨域是利用 script 标签不受同源策略的影响，将要请求的地址添加到 script 标签的 src 属性中，再将该 script 标签添加到页面。在资源加载后立即执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 客户端</span></span><br><span class="line">&lt;script&gt;</span><br><span class="line">   <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">   script.type = <span class="string">'text/javascript'</span>;</span><br><span class="line">   <span class="comment">// 传参并指定回调执行函数为onBack</span></span><br><span class="line">   script.src = <span class="string">'http://www.domain2.com:8080/login?user=admin&amp;callback=onBack'</span>;</span><br><span class="line">   <span class="built_in">document</span>.head.appendChild(script);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 回调执行函数</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">onBack</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">       alert(<span class="built_in">JSON</span>.stringify(res));</span><br><span class="line">   &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">   /</span><span class="regexp">/ 服务器</span></span><br><span class="line"><span class="regexp">onBack(&#123;"status": true, "user": "admin"&#125;)</span></span><br></pre></td></tr></table></figure>
<p><strong>缺点</strong>：只支持 get 方法</p>
<p>jsonp 看似和 json 很像，它是包含在函数调用中的 json。</p>
<h3 id="3-CORS（Cross-Origin-Resource-Sharing-跨源资源共享）"><a href="#3-CORS（Cross-Origin-Resource-Sharing-跨源资源共享）" class="headerlink" title="3.CORS（Cross-Origin Resource Sharing 跨源资源共享）"></a>3.CORS（Cross-Origin Resource Sharing 跨源资源共享）</h3><p>CORS的原理，就是使用自定义的HTTP头部让浏览器和服务器通信，从而决定请求或响应应该成功还是失败。首先 CORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。整个CORS通信过程，浏览器在发请求时会添加一个 Origin 字段（浏览器端自动完成，不需要用户参与），用于告诉服务器请求页面的源信息。服务器根据 Origin 的值决定是否允许该跨域请求，默认情况是不允许的。</p>
<p>具体操作是在后端设置一个 Access-Control-Allow-Origin 的响应头，值为允许发送跨域请求的地址。浏览器判断该响应头中是否包含 Origin 的值，如果包含浏览器则处理响应，否则直接驳回，无法得到响应数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务器</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcConfig</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addMapping(<span class="string">"/**"</span>)</span><br><span class="line">                .allowedOrigins(<span class="string">"*"</span>)</span><br><span class="line">                .allowedMethods(<span class="string">"*"</span>)</span><br><span class="line">                .allowCredentials(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他字段</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）Access-Control-Allow-Origin</span><br><span class="line"><span class="comment">//用来告诉浏览器服务端接收哪些域的请求，值可以是一个具体的域名（www.baidu.com）,也可以是通配符（*）</span></span><br><span class="line">（<span class="number">2</span>）Access-Control-Allow-Credentials</span><br><span class="line"><span class="comment">//用来标识服务端是否允许发送Cookie，需要搭配XMLHttpRequest的withCredentials一起使用。</span></span><br><span class="line"><span class="comment">//如果设置为发送Cookie时，Access-Control-Allow-Origin必须制定具体域名，而不能是通配符（*）</span></span><br><span class="line">（<span class="number">3</span>）Access-Control-Expose-Headers</span><br><span class="line"><span class="comment">//用来标识允许获取的返回头内容</span></span><br><span class="line">（<span class="number">4</span>）Access-Control-Allow-Methods</span><br><span class="line"><span class="comment">//该值必需，用来告诉浏览器服务端支持的所有请求类型</span></span><br><span class="line">（<span class="number">5</span>）Access-Control-Allow-Headers</span><br><span class="line"><span class="comment">//如果是复杂请求，该值必需。用来表明服务器支持的所有头信息</span></span><br><span class="line">（<span class="number">6</span>）Access-Control-Max-Age</span><br><span class="line"><span class="comment">//标识复杂请求下预检请求的有效期。</span></span><br></pre></td></tr></table></figure><div class="qr-code"></div><img class="qrcode-img" src="/img/weixin.jpg"><div class="qrcode-desc">微信打赏</div><div class="post-tag-list">标签: <a class="post-tags" href="/tags/JavaScript/">JavaScript</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2018/07/16/计算机网络总/"><i class="fa fa-chevron-left"></i><span>计算机网络</span></a></div><div class="next-post pull-right"><a href="/2018/06/01/vue生命周期/"><span>vue生命周期</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: 'e238e2d1f25ec6e15026',
  clientSecret: '3c4e537d46a59d056e6c0cc478b04784defafcfb',
  repo: 'Yin-Hongwei.github.io',
  owner: 'Yin-Hongwei',
  admin: 'Yin-Hongwei',
  id: md5(window.location.pathname)
})
gitalk.render('gitalk-container')</script></article></section></article><footer id="footer-outer"><div id="footer-inner"><p class="footer-text">Copyright &copy; 2018-2020</p><p class="footer-text">Designed by Yin-Hongwei</p></div></footer></body><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="/js/main.js" defer></script></html>