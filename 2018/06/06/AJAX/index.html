<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="AJAX 回调地狱和跨域问题"><meta name="keywords" content="JavaScript"><meta name="author" content="Yin-Hongwei"><meta name="copyright" content="Yin-Hongwei"><title>AJAX 回调地狱和跨域问题 | Hongwei Blog</title><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script></head><body><header id="page-header"><nav id="navbar"><span class="nav-left"><div class="tou-img"><img src="/img/tou.jpg"></div><a id="site-name" href="/">Hongwei Blog</a></span><i class="fa fa-bars toggle-menu nav-right" aria-hidden="true"></i><span class="nav-right menus"><a class="site-page" href="/about">关于</a><a class="site-page" href="/archives">存档</a><a class="site-page" href="/tags">标签</a></span></nav></header><article id="content-outer"><section id="content-inner"><article class="article-entry" id="post"><h1>AJAX 回调地狱和跨域问题</h1><h2 id="一、AJAX"><a href="#一、AJAX" class="headerlink" title="一、AJAX"></a>一、AJAX</h2><p>Ajax 通过 XMLHttpRequest 对象能够与远程的服务器进行信息交互。在需要发送多个异步请求，并且每个请求之间需要相互依赖的时候，它返回的顺序不确定，有时候得不到我们想要的结果，如果想解决这个问题，这个时候要把下一个请求写到上一个请求的回调函数里，即嵌套方式来解决。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">doSomething(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">  doSomethingElse(result, <span class="function"><span class="keyword">function</span>(<span class="params">newResult</span>) </span>&#123;</span><br><span class="line">    doThirdThing(newResult, <span class="function"><span class="keyword">function</span>(<span class="params">finalResult</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Got the final result: '</span> + finalResult);</span><br><span class="line">    &#125;, failureCallback);</span><br><span class="line">  &#125;, failureCallback);</span><br><span class="line">&#125;, failureCallback);</span><br></pre></td></tr></table></figure>
<p>但是这样一层一层的嵌套，使回调函数的层级越来越多，很可能坠入回调地狱中，维护困难。为了解决这种回调顺序的不确定性，以及回调地狱，于是出现了 <strong>Promise</strong>。</p>
<h2 id="二-Promise"><a href="#二-Promise" class="headerlink" title="二 Promise"></a>二 Promise</h2><h3 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h3><p>Promise 是一个对象，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。它将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。</p>
<h3 id="2、特点"><a href="#2、特点" class="headerlink" title="2、特点"></a>2、特点</h3><ul>
<li>对象的状态不受外界影响。<code>Promise</code>对象代表一个异步操作，有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和<code>rejected</code>（已失败）。只有异步操作的结果可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。</li>
<li>一旦状态改变，就不会再变，任何时候都可以得到这个结果。<code>Promise</code>对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>。只要这两种情况发生，状态就不会再变，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对<code>Promise</code>对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</li>
</ul>
<h3 id="3、缺点"><a href="#3、缺点" class="headerlink" title="3、缺点"></a>3、缺点</h3><ul>
<li>无法取消<code>Promise</code>，一旦新建它就会立即执行，无法中途取消。</li>
<li>如果不设置回调函数，<code>Promise</code>内部抛出的错误，不会反应到外部。</li>
<li>当处于<code>pending</code>状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</li>
</ul>
<h2 id="三、Axios"><a href="#三、Axios" class="headerlink" title="三、Axios"></a>三、Axios</h2><p>Axios 是一个基于 promise 的 HTTP 库，支持Promise API，能帮助我们发起AJAX请求。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">axios.get(‘ https:<span class="comment">//baidu……’)</span></span><br><span class="line">.then(res = &gt; &#123;…&#125;)</span><br><span class="line">.catch(err = &gt; &#123;…&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="四、跨域"><a href="#四、跨域" class="headerlink" title="四、跨域"></a>四、跨域</h2><h3 id="同源策略：浏览器的一种安全机制"><a href="#同源策略：浏览器的一种安全机制" class="headerlink" title="同源策略：浏览器的一种安全机制"></a>同源策略：浏览器的一种安全机制</h3><p>URL由协议、域名、端口和路径组成，如果两个URL的协议、域名和端口相同，则表示他们同源。当浏览器从一个域名的网页去请求另一个域名的资源时，协议、域名、端口任一一个不同都是跨域。AJAX 受同源策略影响，不能发送跨域请求。下面是解决跨域的几种方式。</p>
<h3 id="1、JSONP"><a href="#1、JSONP" class="headerlink" title="1、JSONP"></a>1、JSONP</h3><p>JSONP 实现跨域是利用 script 标签不受同源策略的影响，将要请求的地址添加到 script 标签的 src 属性中，再将该 script 标签添加到页面。在资源加载后立即执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 客户端</span></span><br><span class="line">&lt;script&gt;</span><br><span class="line">   <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">   script.type = <span class="string">'text/javascript'</span>;</span><br><span class="line">   <span class="comment">// 传参并指定回调执行函数为onBack</span></span><br><span class="line">   script.src = <span class="string">'http://www.domain2.com:8080/login?user=admin&amp;callback=onBack'</span>;</span><br><span class="line">   <span class="built_in">document</span>.head.appendChild(script);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 回调执行函数</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">onBack</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">       alert(<span class="built_in">JSON</span>.stringify(res));</span><br><span class="line">   &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">   /</span><span class="regexp">/ 服务器</span></span><br><span class="line"><span class="regexp">onBack(&#123;"status": true, "user": "admin"&#125;)</span></span><br></pre></td></tr></table></figure>
<p><strong>缺点</strong>：只支持 get 方法</p>
<p>jsonp 看似和 json 很像，它是包含在函数调用中的 json。</p>
<h3 id="2、远程代理"><a href="#2、远程代理" class="headerlink" title="2、远程代理"></a>2、远程代理</h3><p>同源策略是浏览器的安全策略，不是HTTP协议的要求。所以只要将请求的发送方交由服务端发送就可以绕过同源策略了。远程代理就是利用别人写好的代理接口代理发送你的请求，就不存在跨域问题了。</p>
<p>首先我们定义一个常量  API_PROXY 来保存代理的接口</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> API_PROXY = <span class="string">'https://bird.ioliu.cn/v1/?url='</span></span><br></pre></td></tr></table></figure>
<p>然后在axios请求里面和你的url拼接一下就OK了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axios.get(_this.$store.state.API_PROXY + <span class="string">'http://news-at.zhihu.com/api/4/stories/latest'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="3、CORS（Cross-Origin-Resource-Sharing-跨源资源共享）"><a href="#3、CORS（Cross-Origin-Resource-Sharing-跨源资源共享）" class="headerlink" title="3、CORS（Cross-Origin Resource Sharing 跨源资源共享）"></a>3、CORS（Cross-Origin Resource Sharing 跨源资源共享）</h3><p>CORS的原理，就是使用自定义的HTTP头部让浏览器和服务器通信，从而决定请求或响应应该成功还是失败。首先 CORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。整个CORS通信过程，浏览器在发请求时会添加一个 Origin 字段（浏览器端自动完成，不需要用户参与），用于告诉服务器请求页面的源信息。服务器根据 Origin 的值决定是否允许该跨域请求，默认情况是不允许的。</p>
<p>具体操作是在后端设置一个 Access-Control-Allow-Origin 的响应头，值为允许发送跨域请求的地址。浏览器判断该响应头中是否包含 Origin 的值，如果包含浏览器则处理响应，否则直接驳回，无法得到响应数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务器</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcConfig</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addMapping(<span class="string">"/**"</span>)</span><br><span class="line">                .allowedOrigins(<span class="string">"*"</span>)</span><br><span class="line">                .allowedMethods(<span class="string">"*"</span>)</span><br><span class="line">                .allowCredentials(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他字段</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）Access-Control-Allow-Origin</span><br><span class="line"><span class="comment">//用来告诉浏览器服务端接收哪些域的请求，值可以是一个具体的域名（www.baidu.com）,也可以是通配符（*）</span></span><br><span class="line">（<span class="number">2</span>）Access-Control-Allow-Credentials</span><br><span class="line"><span class="comment">//用来标识服务端是否允许发送Cookie，需要搭配XMLHttpRequest的withCredentials一起使用。</span></span><br><span class="line"><span class="comment">//如果设置为发送Cookie时，Access-Control-Allow-Origin必须制定具体域名，而不能是通配符（*）</span></span><br><span class="line">（<span class="number">3</span>）Access-Control-Expose-Headers</span><br><span class="line"><span class="comment">//用来标识允许获取的返回头内容</span></span><br><span class="line">（<span class="number">4</span>）Access-Control-Allow-Methods</span><br><span class="line"><span class="comment">//该值必需，用来告诉浏览器服务端支持的所有请求类型</span></span><br><span class="line">（<span class="number">5</span>）Access-Control-Allow-Headers</span><br><span class="line"><span class="comment">//如果是复杂请求，该值必需。用来表明服务器支持的所有头信息</span></span><br><span class="line">（<span class="number">6</span>）Access-Control-Max-Age</span><br><span class="line"><span class="comment">//标识复杂请求下预检请求的有效期。</span></span><br></pre></td></tr></table></figure><div class="qr-code"></div><img class="qrcode-img" src="/img/weixin.jpg"><div class="qrcode-desc">微信打赏</div><div class="post-tag-list">标签: <a class="post-tags" href="/tags/JavaScript/">JavaScript</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2018/08/01/vue响应式原理/"><i class="fa fa-chevron-left"></i><span>Vue 双向数据绑定</span></a></div><div class="next-post pull-right"><a href="/2018/06/01/vue生命周期/"><span>Vue 生命周期</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: 'e238e2d1f25ec6e15026',
  clientSecret: '3c4e537d46a59d056e6c0cc478b04784defafcfb',
  repo: 'Yin-Hongwei.github.io',
  owner: 'Yin-Hongwei',
  admin: 'Yin-Hongwei',
  id: md5(window.location.pathname)
})
gitalk.render('gitalk-container')</script></article></section></article><footer id="footer-outer"><div id="footer-inner"><p class="footer-text">Copyright &copy; 2018-2020</p><p class="footer-text">Designed by Yin-Hongwei</p></div></footer></body><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="/js/main.js" defer></script><script src="/js/scroll.js" defer></script></html>