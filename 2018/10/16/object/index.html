<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="javascript 之 对象"><meta name="keywords" content="JavaScript"><meta name="author" content="Yin-Hongwei"><meta name="copyright" content="Yin-Hongwei"><title>Hongwei Blog</title><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"></head><body><header id="header"><nav id="navbar"><span class="nav-left"><a id="site-name" href="/">Hongwei Blog</a></span><i class="fa fa-bars toggle-menu nav-right" aria-hidden="true"></i><span class="nav-right menus"><a class="site-page" href="/about">关于</a><a class="site-page" href="/archives">存档</a><a class="site-page" href="/tags">标签</a></span></nav></header><article id="content-outer"><section id="content-inner"><article class="article-entry" id="post"><h1>javascript 之 对象</h1><p>可以通过 Object 构造函数或对象字面量的方式创建对象，但是这些方式的缺点是使用同一个接口创建多个对象，会产生大量重复的代码。</p>
<a id="more"></a>
<h2 id="1-工厂模式"><a href="#1-工厂模式" class="headerlink" title="1.工厂模式"></a>1.工厂模式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  o.name = name;</span><br><span class="line">  o.age = age;</span><br><span class="line">  o.job = job;</span><br><span class="line">  o.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = createPerson(<span class="string">'Nike'</span>, <span class="number">18</span>, <span class="string">'Student'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person1.constructor.name) <span class="comment">// Object</span></span><br></pre></td></tr></table></figure>
<p>优点：解决了创建多个相似对象的问题。</p>
<p>缺点：没有解决对象的识别问题（如何知道一个对象的类型）</p>
<h2 id="2-构造函数模式"><a href="#2-构造函数模式" class="headerlink" title="2.构造函数模式"></a>2.构造函数模式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.job = job;</span><br><span class="line">  <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'Nike'</span>, <span class="number">18</span>, <span class="string">'Student'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person1.constructor.name) <span class="comment">// Person</span></span><br></pre></td></tr></table></figure>
<p>优点：可以将构造函数的实例标识为一种特定的类型</p>
<p>缺点：每个方法在每个实例上都要重新创建一次（它们做的事情都一样），如果方法写成全局函数就没有封装性可言了。</p>
<h2 id="3-原型模式"><a href="#3-原型模式" class="headerlink" title="3.原型模式"></a>3.原型模式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span>: Person,</span><br><span class="line">  name: 'Nike',</span><br><span class="line">  friends: ['阿猫', '阿狗']</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person1 = new Person();</span><br><span class="line">var person2 = new Person();</span><br><span class="line"></span><br><span class="line">person1.friends.push('阿黄');</span><br><span class="line">console.log(person1.friends); // ['阿猫', '阿狗', '阿黄']</span><br><span class="line">console.log(person2.friends); // ['阿猫', '阿狗', '阿黄']</span><br></pre></td></tr></table></figure>
<p>缺点</p>
<ul>
<li>不能用构造函数传递初始化参数，使得所有实例默认情况下取得相同的属性值。</li>
<li>原型中的属性在很多实例中共享，当属性是基本值的时候可以实例上添加一个同名属性隐藏原型中对应的属性，但当属性是引用类型的时候，修改一个实例的属性时是在原型上直接修改的，其它实例的属性也会更着改变。</li>
</ul>
<h2 id="4-组合使用构造函数和原型模式"><a href="#4-组合使用构造函数和原型模式" class="headerlink" title="4.组合使用构造函数和原型模式"></a>4.组合使用构造函数和原型模式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.job = job;</span><br><span class="line">  <span class="keyword">this</span>.friends: [<span class="string">'阿猫'</span>, <span class="string">'阿狗'</span>]</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span>: Person,</span><br><span class="line">  sayName : function () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'Nike'</span>, <span class="number">18</span>, <span class="string">'Student'</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">'Bob'</span>, <span class="number">22</span>, <span class="string">'Doctor'</span>);</span><br><span class="line"></span><br><span class="line">person1.friends.push(<span class="string">'阿黄'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person1.friends); <span class="comment">// ['阿猫', '阿狗', '阿黄']</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.friends); <span class="comment">// ['阿猫', '阿狗']</span></span><br></pre></td></tr></table></figure>
<p>思想：用构造函数模式定义实例属性，原型模式定义方法和共享的属性</p>
<p>优点</p>
<ul>
<li>每个实例都有自己的一份属性的副本，同时共享着方法的引用，节约内存</li>
<li>支持构造函数传参</li>
</ul>
<h2 id="5-动态原型模式"><a href="#5-动态原型模式" class="headerlink" title="5.动态原型模式"></a>5.动态原型模式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.job = job;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName != <span class="string">'function'</span>) &#123; <span class="comment">// 检查初始化之后应该存在的任何属性和方法</span></span><br><span class="line">    Person.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person(<span class="string">'Nike'</span>, <span class="number">18</span>, <span class="string">'Student'</span>); </span><br><span class="line">friend.sayName();</span><br></pre></td></tr></table></figure>
<p>优点：通过检测某个应该存在的方法在构造函数中初始化原型（必要情况下），即同时使用构造函数和原型</p>
<p>注意：使用动态原型模式是不能使用对象字面量重写原型，因为在已经创建了实例的情况下重写原型会切断现有实例和原型之间的联系。</p>
<h2 id="6-寄生构造函数模式"><a href="#6-寄生构造函数模式" class="headerlink" title="6.寄生构造函数模式"></a>6.寄生构造函数模式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  o.name = name;</span><br><span class="line">  o.age = age;</span><br><span class="line">  o.job = job;</span><br><span class="line">  o.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> friend  = <span class="keyword">new</span> Person(<span class="string">'Nike'</span>, <span class="number">18</span>, <span class="string">'Student'</span>);</span><br><span class="line">friend.sayName(); <span class="comment">// Student</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ======================================================== //</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sp</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> values = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    values.push.apply(values, <span class="built_in">arguments</span>);</span><br><span class="line">    values.toPip = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.join(<span class="string">"|"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> values;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> Sp(<span class="string">'red'</span>,<span class="string">'blue'</span>,<span class="string">'pink'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(colors.toPip()) <span class="comment">// red|blue|pink</span></span><br></pre></td></tr></table></figure>
<p>优点：可以在一些特殊情况下为对象创建构造函数</p>
<p>注意：</p>
<ul>
<li>构造函数没有return的时候，默认会返回新对象实例，有return的时候，可以重写调用构造函数时返回的值。</li>
<li>返回的对象和构造函数或构造函数的原型属性间没有关系。不能用instanceof 确定对象类型</li>
</ul>
<h2 id="7-稳妥构造函数模式"><a href="#7-稳妥构造函数模式" class="headerlink" title="7.稳妥构造函数模式"></a>7.稳妥构造函数模式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  o.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> friend  =  Person(<span class="string">'Nike'</span>, <span class="number">18</span>, <span class="string">'Student'</span>);</span><br><span class="line">friend.sayName(); <span class="comment">// Nike 该属性只能通过 sayName 方法访问</span></span><br></pre></td></tr></table></figure>
<p>概念：稳妥对象，是指没有公共属性，而且其方法不引用 this 的对象。</p>
<p>优点：安全的环境中（禁止使用 this 或 new），或防止数据被其他应用程序改动</p>
<p>注意：</p>
<ul>
<li>创建对象的实例方法不引用 this；不使用 new 操作符调用构造函数。</li>
<li>返回的对象和构造函数或构造函数的原型属性间没有关系。不能用instanceof 确定对象类型</li>
</ul>
<hr><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"><script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: 'e238e2d1f25ec6e15026',
  clientSecret: '3c4e537d46a59d056e6c0cc478b04784defafcfb',
  repo: 'https://github.com/Yin-Hongwei/Yin-Hongwei.github.io',
  owner: 'Yin-Hongwei',
  admin: 'Yin-Hongwei',
  id: page.title
})
gitalk.render('gitalk-container')</script></article></section></article><footer id="footer-outer"><div id="footer-inner"><p class="footer-text">Copyright &copy; 2019</p><p class="footer-text">Designed by Yin-Hongwei</p></div></footer></body><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://hecdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="/js/main.js" defer></script></html>