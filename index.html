<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="Yin-Hongwei"><meta name="copyright" content="Yin-Hongwei"><title>Hongwei Blog</title><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script></head><body><header id="page-header"><nav id="navbar"><span class="nav-left"><div class="tou-img"><img src="/img/tou.jpg"></div><a id="site-name" href="/">Hongwei Blog</a></span><i class="fa fa-bars toggle-menu nav-right" aria-hidden="true"></i><span class="nav-right menus"><a class="site-page" href="/about">关于</a><a class="site-page" href="/archives">存档</a><a class="site-page" href="/tags">标签</a></span></nav></header><article id="content-outer"><section id="content-inner"><section id="recent-posts"><div class="recent-post-item"><div class="post-title"><a href="/2021/06/01/浏览器工作原理/">浏览器工作原理</a><span class="post-time"><time datetime="2021-06-01T14:00:00.000Z">2021-06-01</time></span></div><div class="recent-post-content">浏览器地址栏输入url 到显示页面的步骤1）在浏览器地址栏输入URL
2）浏览器查看缓存，如果资源未缓存，发起新请求，如果已缓存，检验是否过期，如果没过期就直接拿，否则发起请求。
3）发送请求的时候，先要知道服务器的IP地址，所以先进行域名解析。首先现在浏览器缓存里进行查找，然后是本地hosts文件。主机向本地DNS服务器查询，如果没有，本地域名服务器向其他根域名服务器继续发出查询请求报文，根域名服务器要么给出所要查询的 IP 地址，要么告诉本地域名服务器下一步向哪一个域名服务器进行查询。然后让本地域名服务器进行后续的查询。将查询结果告诉主机。
4）客户端通过三次握手和服务器建立TCP链接，
 ...</div><div class="read-more"><a class="more" href="/2021/06/01/浏览器工作原理/#more">ReadMore</a></div></div><div class="recent-post-item"><div class="post-title"><a href="/2020/07/22/前端数据存储方案/">前端数据存储方案</a><span class="post-time"><time datetime="2020-07-22T14:25:00.000Z">2020-07-22</time></span></div><div class="recent-post-content">前言前端数据存储方案主要有 Cookie、Web Storage、IndexedDB 三种。下图为 Chrome 浏览器的存储方案，虽然支持 Web SQL 存储，但是 W3C Web应用工作组于2010年11月停止了对该规范的研究，所以不提倡使用，下面就以上三种存储方案做一下介绍。


一、Cookie1、概念Cookie 指某些网站为了辨别用户身份而储存在用户本地终端上的数据。每次请求都会把本地的 Cookie 发到服务器，让服务器知道当前用户的状态。
Cookie 有域的概念，不能跨域操作。
2、适用场景适合客户端存储较少的数据，用于标识状态（用户登录状态、购物车等）。
3、特点1）数据 ...</div><div class="read-more"><a class="more" href="/2020/07/22/前端数据存储方案/#more">ReadMore</a></div></div><div class="recent-post-item"><div class="post-title"><a href="/2020/06/16/websocket/">WebSocket 入门</a><span class="post-time"><time datetime="2020-06-16T02:00:00.000Z">2020-06-16</time></span></div><div class="recent-post-content">一、WebSocket 协议出现背景HTTP 协议的建立主要是传输 HTML 文档。但随着时代的发展，HTTP 协议的性能遇到了他的的瓶颈。即通信只能是客户端发起请求，这使得服务器有数据发生了变化客户端只有主动发起请求才能获得最新数据。
之后 comet 的出现实现了内容上的实时更新，但是 HTTP 本身的问题并未解决（通信只能客户端发起），于是出现了 WebSocket 协议。

comet 是一种服务器向页面推送数据的技术，实现方式有长轮询和 HTTP 流。

二、WebSocket 协议1、概念WebSocket 协议是 WEB 浏览器和 WEB 服务器全双工通信的标准。诞生于 2008 ...</div><div class="read-more"><a class="more" href="/2020/06/16/websocket/#more">ReadMore</a></div></div><div class="recent-post-item"><div class="post-title"><a href="/2020/03/18/前端模块化/">前端模块化</a><span class="post-time"><time datetime="2020-03-17T19:44:00.000Z">2020-03-18</time></span></div><div class="recent-post-content">一、模块化进化史对于 js 的编写，不能像其他语言一样很好的支持模块化，很多程序会比较臃肿的丢在一个文件里，要把这个程序拆分开使用，两个文件之前变量的传递就是个问题。
模块化的的第一个阶段，是使用的全局模式。假如一个文件要使用另一个文件中的变量，就需要将这个变量定为全局变量，挂到 window  对象上面，这样虽然解决了变量共享的问题，但是这样不仅污染全局对象，而且很容易引起命名冲突覆盖之前的变量。于是，前端模块化的又摸索开始了。
到了第二个阶段，人们开始用对象分装这些数据，这样做避免了命名冲突，但是这些数据可以通过对象直接访问到，即没有做到数据私有化。使得数据不安全。
到了第三个阶段，立即执 ...</div><div class="read-more"><a class="more" href="/2020/03/18/前端模块化/#more">ReadMore</a></div></div><div class="recent-post-item"><div class="post-title"><a href="/2019/11/05/Git工作原理/">Git 工作原理</a><span class="post-time"><time datetime="2019-11-05T15:00:00.000Z">2019-11-05</time></span></div><div class="recent-post-content"><h2 id="一、Git-是什么"><a href="#一、Git-是什么" class="headerlink" title="一、Git 是什么"></a>一、Git 是什么</h2><p>Git 是目前世界上最先进的分布式版本控制工具之一，下面我将通过数据的流向来介绍它。</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcixg7jnb0j30wk09gdg2.jpg" alt=""></p></div><div class="read-more"><a class="more" href="/2019/11/05/Git工作原理/#more">ReadMore</a></div></div><div class="recent-post-item"><div class="post-title"><a href="/2019/11/04/Git命令/">Git 常用命令</a><span class="post-time"><time datetime="2019-11-04T14:00:00.000Z">2019-11-04</time></span></div><div class="recent-post-content"><h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><p><a href="https://git-scm.com/download" target="_blank" rel="noopener">https://git-scm.com/download</a></p></div><div class="read-more"><a class="more" href="/2019/11/04/Git命令/#more">ReadMore</a></div></div><div class="recent-post-item"><div class="post-title"><a href="/2019/08/12/JavaScript动画/">JavaScript 中的动画问题</a><span class="post-time"><time datetime="2019-08-12T14:00:05.000Z">2019-08-12</time></span></div><div class="recent-post-content">实现动画效果方式有很多，可以是 CSS3 的 transition 和 animation，可以是 JavaScript 的 setTimeout、setInterval， 也可以是 html5 的 RequestAnimationFrame。本文主要针对后两种方式做一下介绍。
一、setTimeout、setInterval在 JavaScript 中创建动画的典型方式，就是使用 setInterval() 方法来控制所有动画。如下: 
1234567(function()&#123;  function updateAnimations()&#123;    doAnimation1(); ...</div><div class="read-more"><a class="more" href="/2019/08/12/JavaScript动画/#more">ReadMore</a></div></div><div class="recent-post-item"><div class="post-title"><a href="/2019/07/29/Hexo 主题制作/">Hexo 主题制作</a><span class="post-time"><time datetime="2019-07-29T05:22:00.000Z">2019-07-29</time></span></div><div class="recent-post-content"><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>之前的主题用的是默认的，网上也下载使用过别人写的主题，但是终究还是想用自己写的。所以就写了这个主题——<a href="https://github.com/Yin-Hongwei/hexo-theme-Yin" target="_blank" rel="noopener">Yin</a>。</p></div><div class="read-more"><a class="more" href="/2019/07/29/Hexo 主题制作/#more">ReadMore</a></div></div><div class="recent-post-item"><div class="post-title"><a href="/2019/03/04/music-website/">Vue + SpringBoot + MyBatis 音乐网站</a><span class="post-time"><time datetime="2019-03-03T19:20:00.000Z">2019-03-04</time></span></div><div class="recent-post-content"><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>这里对音乐网站这个项目的开发流程做一下描述，我觉得了解了具体实现的来龙去脉，上手自己做就容易得多了，要知道数据是怎么从数据库一步步跑到前端页面的，当知道了整个的流程再去处理中间的细节，具体实现的细节等有时间了就补充，接下来我们就开始吧。</p>
<p>这是我项目的<a href="https://github.com/Yin-Hongwei/music-website" target="_blank" rel="noopener">地址</a>，可以点开先看看最后的预览图。</p></div><div class="read-more"><a class="more" href="/2019/03/04/music-website/#more">ReadMore</a></div></div><div class="recent-post-item"><div class="post-title"><a href="/2018/12/06/Vue 组件数据传递问题/">Vue 组件数据传递问题总结</a><span class="post-time"><time datetime="2018-12-06T12:00:00.000Z">2018-12-06</time></span></div><div class="recent-post-content">一、组件传值1、父子组件在一个组件中引入令一个组件，被引入的组件就是子组件，外面的是父组件。
当子组件想要使用父组件中的数据，父组件传过来的数据子组件用 props 属性来获取。
12345678910111213141516171819// 父组件&lt;template&gt;  &lt;div class=&quot;father&quot;&gt;    &lt;child :msg = &quot;test&quot;/&gt; // 向自组件传递数据  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import child from XXXe ...</div><div class="read-more"><a class="more" href="/2018/12/06/Vue 组件数据传递问题/#more">ReadMore</a></div></div><div class="recent-post-item"><div class="post-title"><a href="/2018/10/19/原型/">原型</a><span class="post-time"><time datetime="2018-10-19T02:12:12.000Z">2018-10-19</time></span></div><div class="recent-post-content">原型1、原型对象、构造函数、实例对象的关系每个函数都有一个 prototype 属性，它指向一个对象，这个对象就是原型对象。
默认情况下，原型对象上都有一个 constructor 属性，它是一个指向 prototype 属性所在函数的指针。
当调用构造函数创建一个实例后，该对象实例内部有个 proto 属性，指向构造函数的原型对象。
12345678console.log(Object.__proto__ === Function.prototype) //trueconsole.log(Function.__proto__ === Object.prototype) //falsecons ...</div><div class="read-more"><a class="more" href="/2018/10/19/原型/#more">ReadMore</a></div></div><div class="recent-post-item"><div class="post-title"><a href="/2018/10/15/正则表达式/">正则表达式</a><span class="post-time"><time datetime="2018-10-15T11:52:51.000Z">2018-10-15</time></span></div><div class="recent-post-content">一、概念正则表达式是用于匹配字符串中字符组合的模式。
1234var expression = / pattern / flag;// pattern：一个字符串，指定了正则表达式的模式或其他正则表达式。// flag：1）g：全局模式；2）i：不区分大小写模式；3）m：多行模式
二、种类1、简单字符字符本身
1/hello/g
2、方括号用[]指代一个字符，里面的字符表示这个字符的选择范围
1）范围类
-表示一个范围内的字符
1[0-9] &lt;=&gt; [0123456789]
2）组合类
范围类的组合
12[0-9a-fA-F] // 十六进制 // 组合之间不能用空格
3）负向类
 ...</div><div class="read-more"><a class="more" href="/2018/10/15/正则表达式/#more">ReadMore</a></div></div><div class="recent-post-item"><div class="post-title"><a href="/2018/08/17/Event Loop/">Event Loop</a><span class="post-time"><time datetime="2018-08-17T13:52:01.000Z">2018-08-17</time></span></div><div class="recent-post-content">一、概念1、JavaScript 是单线程的脚本语言假定 JS 同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器就不知道以哪个线程为准。
2、call stack（调用栈）是一个记录当前程序所在位置的数据结构，如果当前进入了某个函数，这个函数会被放在栈里面，如果当前离开某个函数，这个函数就会被弹出栈外。 即利用这个栈的特殊结构实现同步。js的运行环境有且只有一个调用栈。
3、WebAPIs（浏览器提供的API）包括 DOM、AJAX、setTimeout 他们不在V8引擎里。是js运行时得到的东西。
4、callback queue（回调队列）回调队列是 ...</div><div class="read-more"><a class="more" href="/2018/08/17/Event Loop/#more">ReadMore</a></div></div><div class="recent-post-item"><div class="post-title"><a href="/2018/08/01/vue响应式原理/">Vue 响应式原理</a><span class="post-time"><time datetime="2018-08-01T14:00:05.000Z">2018-08-01</time></span></div><div class="recent-post-content">一、前言vue 响应式原理是数据渲染到视图，及数据修改触发视图更新的过程。
二、原理
1、数据监听当把一个普通的 JavaScript 对象传入 Vue 实例作为 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 为这些属性设置 getter/setter。
这些 getter/setter 对用户来说不可见，但是在内部它们让 Vue 能够追踪依赖，在属性被访问和修改时通知变更。
1234567891011121314151617181920function defineReactive(obj: Object, key: string, .. ...</div><div class="read-more"><a class="more" href="/2018/08/01/vue响应式原理/#more">ReadMore</a></div></div><div class="recent-post-item"><div class="post-title"><a href="/2018/06/01/vue生命周期/">Vue 生命周期</a><span class="post-time"><time datetime="2018-06-01T14:00:05.000Z">2018-06-01</time></span></div><div class="recent-post-content">一、概念每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。
下图展示了实例的生命周期。

二、执行过程1、beforeCreate / created创建 Vue 实例时，会先执行 initLifecycle 方法注册生命周期的函数，再去执行 beforeCreate 钩子函数，此时还访问不到数据，
当执行 initState 方法初始化 props、data、methods、watch、computed  ...</div><div class="read-more"><a class="more" href="/2018/06/01/vue生命周期/#more">ReadMore</a></div></div><div class="recent-post-item"><div class="post-title"><a href="/2018/04/02/设计/">设计</a><span class="post-time"><time datetime="2018-04-02T12:00:00.000Z">2018-04-02</time></span></div><div class="recent-post-content">大学时期的一些设计作品，做个纪念。
PhotoShop

Maya + Zbrush + Unity3D




速写
</div><div class="read-more"><a class="more" href="/2018/04/02/设计/#more">ReadMore</a></div></div></section><nav id="pagination"><div class="pagination"><span class="page-number current">1</span></div></nav></section></article><footer id="footer-outer"><div id="footer-inner"><p class="footer-text">Copyright &copy; 2018-2021</p><p class="footer-text">Designed by Yin-Hongwei</p></div></footer></body><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="/js/main.js" defer></script><script src="/js/scroll.js" defer></script></html>